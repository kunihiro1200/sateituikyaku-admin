# 歩行距離計算機能 - 要件定義

## 概要
現在の直線距離（Haversine公式）による配信エリア計算を、より正確な歩行距離計算に変更する。

## 背景
- 現在の実装では物件と各エリアの中心点との直線距離を計算している
- 実際の道路に沿った歩行距離の方が、配信エリアの判定により適している
- Google Maps Distance Matrix APIを使用することで、実際の歩行距離を取得できる

## 目標
物件の配信エリア計算において、直線距離ではなく実際の歩行距離を使用する

## 実装アプローチの選択肢

### オプション1: ハイブリッドアプローチ（推奨）
**概要**: 直線距離で初期フィルタリング → 歩行距離で精密計算

**メリット**:
- APIコストを最小限に抑えられる
- 高速な初期フィルタリング
- 精度と効率のバランスが良い

**デメリット**:
- 実装が少し複雑

**コスト見積もり**:
- 初期フィルタで3km以内に絞り込み → 平均2-4エリアに対してAPI呼び出し
- 1物件あたり約2-4リクエスト
- 月間1000物件処理の場合: 2,000-4,000リクエスト = $10-20/月

**実装ステップ**:
1. 直線距離3km以内のエリアを抽出（無料・高速）
2. 抽出されたエリアのみGoogle Maps APIで歩行距離を計算
3. 歩行距離による最終判定（直線3km圏内のため、歩行距離は通常4-5km程度）

### オプション2: 完全歩行距離計算
**概要**: すべてのエリアに対してGoogle Maps APIを使用

**メリット**:
- 最も正確
- 実装がシンプル

**デメリット**:
- APIコストが高い（1物件あたり15-17リクエスト）
- 処理速度が遅い
- ネットワーク障害の影響を受けやすい

**コスト見積もり**:
- 月間1000物件処理の場合: 15,000-17,000リクエスト = $75-85/月

### オプション3: 係数による近似
**概要**: 直線距離 × 1.3 で歩行距離を近似

**メリット**:
- 実装が簡単
- 無料
- 高速

**デメリット**:
- 精度が低い
- 地形や道路状況を考慮できない
- 都市部と郊外で係数が異なる可能性

## 推奨アプローチ: オプション1（ハイブリッド）

### 理由
1. **コスト効率**: APIコストを約70%削減（オプション2比）
2. **精度**: 最終判定は実際の歩行距離を使用
3. **パフォーマンス**: 初期フィルタで不要なAPI呼び出しを削減
4. **信頼性**: API障害時も初期フィルタ結果を使用可能

### 距離設定
- **初期フィルタ（直線距離）**: 3km以内
- **最終判定（歩行距離）**: 変更なし（現在の設定を維持）
  - 現在は10km設定だが、直線3km圏内のみをチェックするため、実際の歩行距離は4-5km程度になる見込み

## 機能要件

### FR-1: Google Maps Distance Matrix API統合
- Google Maps APIキーの設定
- Distance Matrix APIクライアントの実装
- 歩行距離取得メソッドの実装

### FR-2: ハイブリッド距離計算
- 直線距離による初期フィルタリング（3km）
- フィルタ通過エリアに対する歩行距離計算
- 歩行距離による最終判定（通常4-5km程度になる見込み）

### FR-3: エラーハンドリング
- API呼び出し失敗時は直線距離にフォールバック
- レート制限エラーの処理
- タイムアウト処理（5秒）

### FR-4: キャッシング
- 同一座標ペアの結果をキャッシュ
- キャッシュ有効期限: 30日
- メモリキャッシュ + Redis永続化

### FR-5: 設定の柔軟性
- 初期フィルタ半径の設定可能化（デフォルト3km）
- 最終判定半径の設定可能化（デフォルト10km、ただし直線3km圏内のみ対象）
- 歩行距離計算の有効/無効切り替え

## 非機能要件

### NFR-1: パフォーマンス
- 1物件あたりの処理時間: 3秒以内
- API呼び出しの並列化（最大5並列）

### NFR-2: コスト管理
- 月間APIコスト上限: $50
- 上限到達時は直線距離にフォールバック

### NFR-3: 可用性
- API障害時も機能継続（直線距離使用）
- エラーログの記録

### NFR-4: 監視
- API使用量の記録
- エラー率の監視
- 処理時間の監視

## 技術仕様

### 環境変数
```
GOOGLE_MAPS_API_KEY=your_api_key_here
WALKING_DISTANCE_ENABLED=true
INITIAL_FILTER_RADIUS_KM=3
FINAL_RADIUS_KM=10
DISTANCE_CACHE_TTL_DAYS=30
```

### API仕様
Google Maps Distance Matrix API:
- エンドポイント: `https://maps.googleapis.com/maps/api/distancematrix/json`
- パラメータ:
  - `origins`: 物件の座標
  - `destinations`: エリア中心点の座標（複数可）
  - `mode`: walking
  - `language`: ja
  - `key`: APIキー

### データ構造
```typescript
interface WalkingDistanceResult {
  distance: number;        // 歩行距離（km）
  duration: number;        // 所要時間（分）
  straightLineDistance: number;  // 直線距離（km）
  source: 'api' | 'cache' | 'fallback';
}
```

## 実装ファイル

### 新規作成
- `backend/src/services/GoogleMapsDistanceService.ts` - Distance Matrix API クライアント
- `backend/src/services/DistanceCache.ts` - 距離計算結果のキャッシュ
- `backend/src/config/distance-calculation.ts` - 設定管理

### 修正
- `backend/src/services/GeolocationService.ts` - 歩行距離計算メソッド追加
- `backend/src/services/PropertyDistributionAreaCalculator.ts` - ハイブリッド計算ロジック実装
- `backend/.env` - 環境変数追加

## テスト計画

### 単体テスト
- Google Maps APIクライアントのモックテスト
- キャッシュ機能のテスト
- エラーハンドリングのテスト

### 統合テスト
- 実際のAPIを使用した距離計算テスト
- フォールバック動作のテスト

### 検証テスト
- AA13129での検証（既知の結果と比較）
- 複数物件での精度検証

## マイグレーション計画

### フェーズ1: 準備（1日）
- Google Maps APIキーの取得
- 環境変数の設定
- 新規サービスの実装

### フェーズ2: 実装（2日）
- ハイブリッド計算ロジックの実装
- キャッシュ機能の実装
- エラーハンドリングの実装

### フェーズ3: テスト（1日）
- 単体テスト
- 統合テスト
- 既存物件での検証

### フェーズ4: デプロイ（0.5日）
- 本番環境への適用
- 監視設定
- ドキュメント更新

## リスクと対策

### リスク1: APIコスト超過
**対策**: 
- 月間上限の設定
- 使用量の監視
- 上限到達時の自動フォールバック

### リスク2: API障害
**対策**:
- 直線距離へのフォールバック
- リトライロジック
- エラーログの記録

### リスク3: パフォーマンス低下
**対策**:
- 並列処理の実装
- キャッシュの活用
- タイムアウトの設定

## 成功基準

1. ✅ 歩行距離による配信エリア計算が動作する
2. ✅ API呼び出し回数が1物件あたり平均8回以下
3. ✅ 処理時間が1物件あたり3秒以内
4. ✅ API障害時も機能が継続する
5. ✅ 月間APIコストが$50以下

## 参考資料

- [Google Maps Distance Matrix API Documentation](https://developers.google.com/maps/documentation/distance-matrix)
- [Google Maps API Pricing](https://developers.google.com/maps/billing-and-pricing/pricing)
- 現在の実装: `backend/src/services/GeolocationService.ts`
