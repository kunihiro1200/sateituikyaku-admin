/**
 * PropertyImageService
 * ç‰©ä»¶ã®æ ¼ç´å…ˆURLï¼ˆstorage_urlï¼‰ã‹ã‚‰Googleãƒ‰ãƒ©ã‚¤ãƒ–ã®ç”»åƒã‚’å–å¾—ã™ã‚‹ã‚µãƒ¼ãƒ“ã‚¹
 * ç”»åƒã®å‰Šé™¤æ©Ÿèƒ½ã‚‚æä¾›
 */

import { GoogleDriveService, DriveFile } from './GoogleDriveService';
import { createClient } from '@supabase/supabase-js';

const supabaseUrl = process.env.SUPABASE_URL!;
const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY!;
const supabase = createClient(supabaseUrl, supabaseServiceKey);

export interface PropertyImage {
  id: string;
  name: string;
  thumbnailUrl: string;
  fullImageUrl: string;
  mimeType: string;
  size: number;
  modifiedTime: string;
}

export interface PropertyImagesResult {
  images: PropertyImage[];
  folderId: string | null;
  cached: boolean;
}

export interface ImageDeletionResult {
  success: boolean;
  message: string;
  imageId?: string;
  imageName?: string;
}

export interface DeletionLogEntry {
  propertyId: string;
  imageFileId: string;
  imageName?: string;
  deletedBy: string;
  ipAddress?: string;
  success: boolean;
  errorMessage?: string;
}

interface CacheEntry {
  images: PropertyImage[];
  folderId: string;
  cachedAt: number;
  expiresAt: number;
}

export class PropertyImageService {
  private driveService: GoogleDriveService;
  private cache: Map<string, CacheEntry> = new Map();
  private cacheTTL: number; // milliseconds

  constructor(cacheTTLMinutes: number = 60) {
    this.driveService = new GoogleDriveService();
    this.cacheTTL = cacheTTLMinutes * 60 * 1000;
  }

  /**
   * Googleãƒ‰ãƒ©ã‚¤ãƒ–URLã‹ã‚‰ãƒ•ã‚©ãƒ«ãƒ€IDã‚’æŠ½å‡º
   * å¯¾å¿œå½¢å¼:
   * - https://drive.google.com/drive/folders/FOLDER_ID
   * - https://drive.google.com/drive/u/0/folders/FOLDER_ID
   * - https://drive.google.com/drive/folders/FOLDER_ID?usp=sharing
   */
  extractFolderIdFromUrl(url: string): string | null {
    if (!url) return null;

    try {
      // ãƒ•ã‚©ãƒ«ãƒ€IDã‚’æŠ½å‡ºã™ã‚‹æ­£è¦è¡¨ç¾
      const folderIdRegex = /\/folders\/([a-zA-Z0-9_-]+)/;
      const match = url.match(folderIdRegex);
      
      if (match && match[1]) {
        return match[1];
      }
      
      return null;
    } catch (error) {
      console.error('Error extracting folder ID from URL:', error);
      return null;
    }
  }

  /**
   * "athomeå…¬é–‹"ã¾ãŸã¯"atbbå…¬é–‹"ã‚µãƒ–ãƒ•ã‚©ãƒ«ãƒ€ãŒå­˜åœ¨ã™ã‚‹å ´åˆã¯ãã®ãƒ•ã‚©ãƒ«ãƒ€IDã‚’è¿”ã™
   * æ¤œç´¢é †åº: athomeå…¬é–‹ â†’ atbbå…¬é–‹ â†’ è¦ªãƒ•ã‚©ãƒ«ãƒ€
   * å­˜åœ¨ã—ãªã„å ´åˆã¯å…ƒã®ãƒ•ã‚©ãƒ«ãƒ€IDã‚’è¿”ã™
   */
  private async getPublicFolderIdIfExists(parentFolderId: string): Promise<string> {
    try {
      console.log(`ğŸ” Checking for public subfolders in parent: ${parentFolderId}`);
      
      // 1. "athomeå…¬é–‹"ãƒ•ã‚©ãƒ«ãƒ€ã‚’æ¤œç´¢ï¼ˆæœ€å„ªå…ˆï¼‰
      const athomeFolderId = await this.driveService.findFolderByName(parentFolderId, 'athomeå…¬é–‹');
      if (athomeFolderId) {
        console.log(`âœ… Found "athomeå…¬é–‹" subfolder: ${athomeFolderId} in parent: ${parentFolderId}`);
        return athomeFolderId;
      }
      
      // 2. "atbbå…¬é–‹"ãƒ•ã‚©ãƒ«ãƒ€ã‚’æ¤œç´¢ï¼ˆå¾Œæ–¹äº’æ›æ€§ï¼‰
      const atbbFolderId = await this.driveService.findFolderByName(parentFolderId, 'atbbå…¬é–‹');
      if (atbbFolderId) {
        console.log(`âœ… Found "atbbå…¬é–‹" subfolder: ${atbbFolderId} in parent: ${parentFolderId}`);
        return atbbFolderId;
      }
      
      // 3. è¦ªãƒ•ã‚©ãƒ«ãƒ€ã‚’ä½¿ç”¨ï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
      console.log(`ğŸ“ No public subfolder found in parent: ${parentFolderId}, using parent folder`);
      return parentFolderId;
    } catch (error: any) {
      console.error(`âš ï¸ Error checking for public subfolders in parent: ${parentFolderId}:`, error.message);
      console.error(`âš ï¸ Falling back to parent folder`);
      return parentFolderId;
    }
  }

  /**
   * æ ¼ç´å…ˆURLã‹ã‚‰ç”»åƒã‚’å–å¾—
   * "athomeå…¬é–‹"ã¾ãŸã¯"atbbå…¬é–‹"ã‚µãƒ–ãƒ•ã‚©ãƒ«ãƒ€ãŒå­˜åœ¨ã™ã‚‹å ´åˆã¯å„ªå…ˆçš„ã«ãã“ã‹ã‚‰å–å¾—
   * æ¤œç´¢é †åº: athomeå…¬é–‹ â†’ atbbå…¬é–‹ â†’ è¦ªãƒ•ã‚©ãƒ«ãƒ€
   */
  async getImagesFromStorageUrl(storageUrl: string | null | undefined): Promise<PropertyImagesResult> {
    // æ ¼ç´å…ˆURLãŒè¨­å®šã•ã‚Œã¦ã„ãªã„å ´åˆ
    if (!storageUrl) {
      return {
        images: [],
        folderId: null,
        cached: false,
      };
    }

    // ãƒ•ã‚©ãƒ«ãƒ€IDã‚’æŠ½å‡º
    const parentFolderId = this.extractFolderIdFromUrl(storageUrl);
    
    if (!parentFolderId) {
      console.warn(`Invalid storage URL format: ${storageUrl}`);
      return {
        images: [],
        folderId: null,
        cached: false,
      };
    }

    // "athomeå…¬é–‹"ã¾ãŸã¯"atbbå…¬é–‹"ã‚µãƒ–ãƒ•ã‚©ãƒ«ãƒ€ãŒå­˜åœ¨ã™ã‚‹ã‹ç¢ºèªã—ã€å­˜åœ¨ã™ã‚‹å ´åˆã¯ãã®ãƒ•ã‚©ãƒ«ãƒ€IDã‚’ä½¿ç”¨
    // æ¤œç´¢é †åº: athomeå…¬é–‹ â†’ atbbå…¬é–‹ â†’ è¦ªãƒ•ã‚©ãƒ«ãƒ€
    const targetFolderId = await this.getPublicFolderIdIfExists(parentFolderId);

    // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ç¢ºèª
    const cachedResult = this.getFromCache(targetFolderId);
    if (cachedResult) {
      return {
        images: cachedResult.images,
        folderId: cachedResult.folderId,
        cached: true,
      };
    }

    try {
      // Googleãƒ‰ãƒ©ã‚¤ãƒ–ã‹ã‚‰ç”»åƒã‚’å–å¾—
      const driveFiles = await this.driveService.listImagesWithThumbnails(targetFolderId);
      
      // PropertyImageå½¢å¼ã«å¤‰æ›
      const images = this.convertToPropertyImages(driveFiles);
      
      // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ä¿å­˜
      this.saveToCache(targetFolderId, images);
      
      return {
        images,
        folderId: targetFolderId,
        cached: false,
      };
    } catch (error: any) {
      console.error(`Error fetching images from folder ${targetFolderId}:`, error.message);
      
      // ã‚¨ãƒ©ãƒ¼æ™‚ã¯ç©ºã®é…åˆ—ã‚’è¿”ã™ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ä½“é¨“ã‚’æãªã‚ãªã„ï¼‰
      return {
        images: [],
        folderId: targetFolderId,
        cached: false,
      };
    }
  }

  /**
   * DriveFileã‚’PropertyImageå½¢å¼ã«å¤‰æ›
   */
  private convertToPropertyImages(driveFiles: DriveFile[]): PropertyImage[] {
    return driveFiles.map(file => ({
      id: file.id,
      name: file.name,
      // ã‚µãƒ ãƒã‚¤ãƒ«URLã¯ãƒ—ãƒ­ã‚­ã‚·çµŒç”±ã§æä¾›ï¼ˆCORSå¯¾ç­–ï¼‰
      // æ³¨æ„: Google Driveã®ãƒ•ã‚¡ã‚¤ãƒ«IDã‚’ãã®ã¾ã¾ä½¿ç”¨
      thumbnailUrl: `https://drive.google.com/thumbnail?id=${file.id}&sz=w400`,
      // ãƒ•ãƒ«ç”»åƒURLã‚‚Google Driveã‹ã‚‰ç›´æ¥å–å¾—
      fullImageUrl: `https://drive.google.com/uc?export=view&id=${file.id}`,
      mimeType: file.mimeType,
      size: file.size,
      modifiedTime: file.modifiedTime,
    }));
  }

  /**
   * ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‹ã‚‰å–å¾—
   */
  private getFromCache(folderId: string): CacheEntry | null {
    const entry = this.cache.get(folderId);
    
    if (!entry) return null;
    
    // æœ‰åŠ¹æœŸé™ã‚’ç¢ºèª
    if (Date.now() > entry.expiresAt) {
      this.cache.delete(folderId);
      return null;
    }
    
    return entry;
  }

  /**
   * ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ä¿å­˜
   */
  private saveToCache(folderId: string, images: PropertyImage[]): void {
    const now = Date.now();
    this.cache.set(folderId, {
      images,
      folderId,
      cachedAt: now,
      expiresAt: now + this.cacheTTL,
    });
  }

  /**
   * ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ã‚¯ãƒªã‚¢
   */
  clearCache(folderId?: string): void {
    if (folderId) {
      this.cache.delete(folderId);
    } else {
      this.cache.clear();
    }
  }

  /**
   * ä¸€è¦§è¡¨ç¤ºç”¨ã«æœ€åˆã®1æšã®ç”»åƒURLã®ã¿ã‚’å–å¾—
   * ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–ã®ãŸã‚ã€ã‚µãƒ ãƒã‚¤ãƒ«ç”¨ã«ä½¿ç”¨
   * "athomeå…¬é–‹"ã¾ãŸã¯"atbbå…¬é–‹"ã‚µãƒ–ãƒ•ã‚©ãƒ«ãƒ€ãŒå­˜åœ¨ã™ã‚‹å ´åˆã¯å„ªå…ˆçš„ã«ãã“ã‹ã‚‰å–å¾—
   * æ¤œç´¢é †åº: athomeå…¬é–‹ â†’ atbbå…¬é–‹ â†’ è¦ªãƒ•ã‚©ãƒ«ãƒ€
   * @param propertyId ç‰©ä»¶IDï¼ˆãƒ­ã‚°ç”¨ï¼‰
   * @param storageUrl ç‰©ä»¶ã®æ ¼ç´å…ˆURL
   * @returns ç”»åƒURLã®é…åˆ—ï¼ˆæœ€å¤§1ä»¶ï¼‰
   */
  async getFirstImage(propertyId: string, storageUrl: string | null | undefined): Promise<string[]> {
    // æ ¼ç´å…ˆURLãŒè¨­å®šã•ã‚Œã¦ã„ãªã„å ´åˆ
    if (!storageUrl) {
      console.log(`[PropertyImageService] No storage_location for property ${propertyId}`);
      return [];
    }

    // ãƒ•ã‚©ãƒ«ãƒ€IDã‚’æŠ½å‡º
    const parentFolderId = this.extractFolderIdFromUrl(storageUrl);
    if (!parentFolderId) {
      console.warn(`[PropertyImageService] Invalid storage URL format for property ${propertyId}: ${storageUrl}`);
      return [];
    }

    // "athomeå…¬é–‹"ã¾ãŸã¯"atbbå…¬é–‹"ã‚µãƒ–ãƒ•ã‚©ãƒ«ãƒ€ãŒå­˜åœ¨ã™ã‚‹ã‹ç¢ºèªã—ã€å­˜åœ¨ã™ã‚‹å ´åˆã¯ãã®ãƒ•ã‚©ãƒ«ãƒ€IDã‚’ä½¿ç”¨
    // æ¤œç´¢é †åº: athomeå…¬é–‹ â†’ atbbå…¬é–‹ â†’ è¦ªãƒ•ã‚©ãƒ«ãƒ€
    const targetFolderId = await this.getPublicFolderIdIfExists(parentFolderId);

    // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚­ãƒ¼ã‚’folderIdãƒ™ãƒ¼ã‚¹ã«å¤‰æ›´ï¼ˆåŒã˜ãƒ•ã‚©ãƒ«ãƒ€ã‚’è¤‡æ•°ã®ç‰©ä»¶ã§å…±æœ‰ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ãŸã‚ï¼‰
    const cacheKey = `first_image_folder_${targetFolderId}`;
    
    // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ãƒã‚§ãƒƒã‚¯ï¼ˆ5åˆ†é–“ã®TTLï¼‰
    const cachedEntry = this.cache.get(cacheKey);
    if (cachedEntry && Date.now() < cachedEntry.expiresAt) {
      console.log(`[PropertyImageService] Cache hit for property ${propertyId}, folder ${targetFolderId}`);
      // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã•ã‚ŒãŸç”»åƒã®ãƒ—ãƒ­ã‚­ã‚·URLã‚’è¿”ã™
      return cachedEntry.images.length > 0 
        ? [`/api/public/images/${cachedEntry.images[0].id}/thumbnail`] 
        : [];
    }

    try {
      console.log(`[PropertyImageService] Fetching images for property ${propertyId} from folder ${targetFolderId}`);
      
      // Googleãƒ‰ãƒ©ã‚¤ãƒ–ã‹ã‚‰ç”»åƒã‚’å–å¾—
      const driveFiles = await this.driveService.listImagesWithThumbnails(targetFolderId);
      
      // ç”»åƒãŒãªã„å ´åˆ
      if (driveFiles.length === 0) {
        console.log(`[PropertyImageService] No images found in folder ${targetFolderId} for property ${propertyId}`);
        
        // ç”»åƒãŒãªã„å ´åˆã¯çŸ­æ™‚é–“ã‚­ãƒ£ãƒƒã‚·ãƒ¥ï¼ˆ1åˆ†ï¼‰
        const now = Date.now();
        this.cache.set(cacheKey, {
          images: [],
          folderId: targetFolderId,
          cachedAt: now,
          expiresAt: now + (1 * 60 * 1000), // 1åˆ†é–“
        });
        
        return [];
      }

      // PropertyImageå½¢å¼ã«å¤‰æ›
      const images = this.convertToPropertyImages(driveFiles);
      
      console.log(`[PropertyImageService] Found ${images.length} images in folder ${targetFolderId} for property ${propertyId}`);
      
      // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ä¿å­˜ï¼ˆ5åˆ†é–“ï¼‰
      const now = Date.now();
      this.cache.set(cacheKey, {
        images,
        folderId: targetFolderId,
        cachedAt: now,
        expiresAt: now + (5 * 60 * 1000), // 5åˆ†é–“
      });
      
      // æœ€åˆã®1æšã®ãƒ—ãƒ­ã‚­ã‚·URLã‚’è¿”ã™ï¼ˆGoogle Driveç›´æ¥URLã¯èªè¨¼ãŒå¿…è¦ãªãŸã‚ï¼‰
      return [`/api/public/images/${images[0].id}/thumbnail`];
    } catch (error: any) {
      console.error(`[PropertyImageService] Error fetching first image for property ${propertyId} from folder ${targetFolderId}:`, error.message);
      console.error(`[PropertyImageService] Error details:`, error);
      
      // ã‚¨ãƒ©ãƒ¼æ™‚ã¯ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã—ãªã„ï¼ˆæ¬¡å›ãƒªãƒˆãƒ©ã‚¤å¯èƒ½ã«ã™ã‚‹ï¼‰
      return [];
    }
  }

  /**
   * ç”»åƒãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ï¼ˆãƒ—ãƒ­ã‚­ã‚·ç”¨ï¼‰
   */
  async getImageData(fileId: string): Promise<{ buffer: Buffer; mimeType: string } | null> {
    try {
      const result = await this.driveService.getImageData(fileId);
      return {
        buffer: result.buffer,
        mimeType: result.mimeType,
      };
    } catch (error: any) {
      console.error(`Error fetching image data for ${fileId}:`, error.message);
      return null;
    }
  }

  /**
   * ç”»åƒãŒãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®ãƒ•ã‚©ãƒ«ãƒ€ã«å±ã—ã¦ã„ã‚‹ã‹æ¤œè¨¼
   * @param _propertyId ç‰©ä»¶IDï¼ˆå°†æ¥ã®æ‹¡å¼µç”¨ã€ç¾åœ¨ã¯æœªä½¿ç”¨ï¼‰
   * @param fileId Google Driveãƒ•ã‚¡ã‚¤ãƒ«ID
   * @param storageUrl ç‰©ä»¶ã®æ ¼ç´å…ˆURL
   * @returns ç”»åƒãŒãƒ•ã‚©ãƒ«ãƒ€ã«å±ã—ã¦ã„ã‚‹å ´åˆã¯true
   */
  async validateImageBelongsToProperty(
    _propertyId: string,
    fileId: string,
    storageUrl: string | null | undefined
  ): Promise<boolean> {
    if (!storageUrl) {
      return false;
    }

    const folderId = this.extractFolderIdFromUrl(storageUrl);
    if (!folderId) {
      return false;
    }

    try {
      // ãƒ•ã‚©ãƒ«ãƒ€å†…ã®ç”»åƒä¸€è¦§ã‚’å–å¾—
      const driveFiles = await this.driveService.listImagesWithThumbnails(folderId);
      
      // æŒ‡å®šã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«IDãŒãƒ•ã‚©ãƒ«ãƒ€å†…ã«å­˜åœ¨ã™ã‚‹ã‹ç¢ºèª
      return driveFiles.some(file => file.id === fileId);
    } catch (error: any) {
      console.error(`Error validating image belongs to property:`, error.message);
      return false;
    }
  }

  /**
   * ç”»åƒã‚’å‰Šé™¤
   * @param fileId Google Driveãƒ•ã‚¡ã‚¤ãƒ«ID
   * @param propertyId ç‰©ä»¶ID
   * @param storageUrl ç‰©ä»¶ã®æ ¼ç´å…ˆURL
   * @param deletedBy å‰Šé™¤å®Ÿè¡Œãƒ¦ãƒ¼ã‚¶ãƒ¼ID
   * @param ipAddress å‰Šé™¤å®Ÿè¡Œå…ƒIPã‚¢ãƒ‰ãƒ¬ã‚¹
   * @returns å‰Šé™¤çµæœ
   */
  async deleteImage(
    fileId: string,
    propertyId: string,
    storageUrl: string | null | undefined,
    deletedBy: string,
    ipAddress?: string
  ): Promise<ImageDeletionResult> {
    let imageName: string | undefined;

    try {
      // ç”»åƒãŒãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã«å±ã—ã¦ã„ã‚‹ã‹æ¤œè¨¼
      const isValid = await this.validateImageBelongsToProperty(propertyId, fileId, storageUrl);
      if (!isValid) {
        await this.logDeletion({
          propertyId,
          imageFileId: fileId,
          deletedBy,
          ipAddress,
          success: false,
          errorMessage: 'ç”»åƒãŒè¦‹ã¤ã‹ã‚‰ãªã„ã‹ã€ã“ã®ç‰©ä»¶ã«å±ã—ã¦ã„ã¾ã›ã‚“',
        });
        return {
          success: false,
          message: 'ç”»åƒãŒè¦‹ã¤ã‹ã‚‰ãªã„ã‹ã€ã“ã®ç‰©ä»¶ã«å±ã—ã¦ã„ã¾ã›ã‚“',
          imageId: fileId,
        };
      }

      // ç”»åƒã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ï¼ˆãƒ­ã‚°ç”¨ï¼‰
      try {
        const metadata = await this.driveService.getFileMetadata(fileId);
        imageName = metadata?.name;
      } catch (e) {
        // ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿å–å¾—ã«å¤±æ•—ã—ã¦ã‚‚å‰Šé™¤ã¯ç¶šè¡Œ
      }

      // Google Driveã‹ã‚‰ç”»åƒã‚’å‰Šé™¤
      await this.driveService.deleteFile(fileId);

      // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ã‚¯ãƒªã‚¢
      const folderId = this.extractFolderIdFromUrl(storageUrl!);
      if (folderId) {
        this.clearCache(folderId);
      }

      // å‰Šé™¤ãƒ­ã‚°ã‚’è¨˜éŒ²
      await this.logDeletion({
        propertyId,
        imageFileId: fileId,
        imageName,
        deletedBy,
        ipAddress,
        success: true,
      });

      return {
        success: true,
        message: 'ç”»åƒã‚’å‰Šé™¤ã—ã¾ã—ãŸ',
        imageId: fileId,
        imageName,
      };
    } catch (error: any) {
      console.error(`Error deleting image ${fileId}:`, error.message);

      // å‰Šé™¤å¤±æ•—ãƒ­ã‚°ã‚’è¨˜éŒ²
      await this.logDeletion({
        propertyId,
        imageFileId: fileId,
        imageName,
        deletedBy,
        ipAddress,
        success: false,
        errorMessage: error.message,
      });

      return {
        success: false,
        message: `ç”»åƒã®å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ: ${error.message}`,
        imageId: fileId,
        imageName,
      };
    }
  }

  /**
   * å‰Šé™¤ãƒ­ã‚°ã‚’è¨˜éŒ²
   */
  private async logDeletion(entry: DeletionLogEntry): Promise<void> {
    try {
      await supabase.from('property_image_deletion_logs').insert({
        property_id: entry.propertyId,
        image_file_id: entry.imageFileId,
        image_name: entry.imageName,
        deleted_by: entry.deletedBy,
        ip_address: entry.ipAddress,
        success: entry.success,
        error_message: entry.errorMessage,
      });
    } catch (error: any) {
      console.error('Error logging deletion:', error.message);
      // ãƒ­ã‚°è¨˜éŒ²ã®å¤±æ•—ã¯ç„¡è¦–ï¼ˆãƒ¡ã‚¤ãƒ³å‡¦ç†ã«å½±éŸ¿ã•ã›ãªã„ï¼‰
    }
  }
}
